[{"name": "app.py", "content": "from shiny.express import input, render, ui\nfrom shiny import reactive\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom matplotlib.patches import Rectangle\nimport time\n\nplot_width: float = 100.0\nplot_height: float = 100.0\nbox_width: float = 30.0\nbox_height: float = 30.0\nbox_color: str = 'white'\nbox_edge_sliding_color: str = 'red'\nbox_edge_stationary_color: str = 'green'\nanchor_x: float = plot_width / 2 - box_width / 2\noriginal_x: float = anchor_x\nslope_x = np.array([0,100])\nangle: float = 19\nmass: float = 100\nmu: float = 0.168\ng: float = 9.8\n\nui.page_opts(title=\"Reaction force, normal force and friction\", fillable=True)\n\ndef rad(angle: float) -> float:\n    return angle / 180 * np.pi\n\nwith ui.layout_sidebar():\n    with ui.sidebar(bg='#09AAFF'):\n        ui.input_text(\"angle\", \"Slope Angle:\", str(angle))\n        ui.input_slider(\"angle_slider\", \"\", min=0, max=60, value=angle, step=0.001)\n        ui.input_text(\"mass\", \"Mass / kg\", str(mass))\n        ui.input_text(\"mu\", \"Coefficient Of Friction\", str(mu))\n        ui.input_slider(\"mu_slider\", \"\", min=0, max=1, value=mu, step=0.001)\n        ui.input_slider(\"time\", \"Animate\", min=0, max=100,value=0, step=2, animate=True)\n\n    with ui.card(height = 600):\n        @reactive.effect\n        def store_angle() -> None:\n            try:\n                global angle\n                angle = float(input.angle())\n            except:\n                f'error: setting angle = {angle}; input.angle() = {input.angle()}'\n\n        @reactive.effect\n        def store_mu() -> None:\n            try:\n                global mu\n                mu = float(input.mu())\n            except:\n                f'error: setting mu = {mu}; input.mu() = {input.mu()}'\n\n        @reactive.effect\n        def store_mass() -> None:\n            try:\n                global mass\n                mass = float(input.mass())\n            except:\n                f'error: setting mass = {mass}; input.mass() = {input.mass()}'\n\n        def calc_y(x: float) -> None:\n            if  angle <= 60:\n                return np.tan(rad(angle)) * x\n\n        def create_rectangle(anchor_x: float, _anchor_y: float, width: float, height: float, angle: float) -> matplotlib.patches.Rectangle:\n            edge_color = box_edge_sliding_color if is_sliding() else box_edge_stationary_color\n            return Rectangle((anchor_x, _anchor_y), width, height, angle=angle, lw=5, facecolor = box_color, edgecolor = edge_color) #use rotation_point parameter default = 'xy' = bottom left corner (x, y) available in later matplotlive versions?\n\n        def is_sliding() -> bool:\n            try:\n                crit_angle = np.arccos(np.sqrt(1/(1+float(input.mu())**2))) / np.pi * 180\n                print(f'critical angle is: {crit_angle}')\n                if float(input.angle()) > crit_angle:\n                    return True\n                else:\n                    return False\n            except:\n                print(f'error: coefficient of friction was {input.mu()}; input angle was {input.angle()}')\n\n        @reactive.effect\n        def update_angle() -> None:\n            ui.update_text(\"angle\", value=str(input.angle_slider()))\n\n        @reactive.effect\n        def update_angle_slider() -> None:\n            ui.update_slider(\"angle_slider\", value=str(input.angle()))\n\n        @reactive.effect\n        def update_angle() -> None:\n            ui.update_text(\"mu\", value=str(input.mu_slider()))\n\n        @reactive.effect\n        def update_angle_slider() -> None:\n            ui.update_slider(\"mu_slider\", value=str(input.mu()))\n\n        @reactive.effect\n        @reactive.event(input.angle, input.mu, input.mass)\n        def calc_forces() -> None:\n            global W_slope\n            global f\n            \n            try:\n                m: float = mass\n                W: float = m * g\n                t: np.array = np.linspace(0, 5, 100)\n                \n                W_slope = W * np.sin(rad(angle))\n                f = mu * W * np.cos(rad(angle)) if angle > 0 else 0\n                \n            except:\n                print(f'error: angle: {input.angle()}, m: {input.mass()}')\n\n        @reactive.effect\n        @reactive.event(input.time)\n        def calc_motion() -> None:\n            global anchor_x\n            \n            try:\n                t: float = float(input.time())\n                downhill_force: float = W_slope - f\n                print(downhill_force)\n                a_slope: float = (W_slope - f) / mass\n\n                #displacement\n                d_slope = -0.5 * a_slope * t**2\n                if downhill_force > 0 and original_x + d_slope * np.cos(rad(angle)) > 0:\n                    anchor_x = original_x + d_slope * np.cos(rad(angle))\n                else:\n                    anchor_x = original_x\n                    ui.update_slider(\"time\",value=str(0))\n            except:\n                ...\n\n        @render.plot\n        @reactive.event(input.angle, input.mu, input.mass, input.time)\n        def plot() -> None:\n            fig, ax = plt.subplots(figsize=(10,12))\n            try:\n                ax.plot(slope_x, calc_y(slope_x), lw=40, zorder=0, c='#09AAFF')\n            except:\n                print(f'error: slope_x = {slope_x}, y = {calc_y(slope_x)}')\n\n            x: float = anchor_x\n            y: float = calc_y(x)\n\n            rect = create_rectangle(x, y, box_width, box_height, angle=angle) # angle in degrees\n            rect_bottom_centre_x = rect.get_x() + box_width/2 * np.cos(rad(angle))\n            rect_bottom_centre_y = calc_y(rect_bottom_centre_x)\n            ax.add_patch(rect)\n\n            w: float = mass * g\n            dy_std = 30\n\n            # weight\n            ax.arrow(rect_bottom_centre_x, rect_bottom_centre_y, dx=0, dy=-dy_std, shape='full', lw=2, head_width=plot_width/50)\n            ax.text(rect_bottom_centre_x + 2, rect_bottom_centre_y - 0.5 * dy_std, f'{str(round(w, 1))} N', fontdict={'size':12})\n\n            # normal\n            ax.arrow(rect_bottom_centre_x, rect_bottom_centre_y, dx=-dy_std*np.sin(rad(angle))*np.cos(rad(angle)), dy=dy_std*np.cos(rad(angle))*np.cos(rad(angle)), shape='full', lw=2, head_width=plot_width/50)\n            ax.text(rect_bottom_centre_x - dy_std*np.sin(rad(angle)) - 8, rect_bottom_centre_y + dy_std*np.cos(rad(angle)) + 8, f'{str(round(w*np.cos(rad(angle)), 1))} N', fontdict={'size':12})\n            if W_slope:\n                ax.arrow(rect_bottom_centre_x, rect_bottom_centre_y, dx=-W_slope/w*dy_std * np.cos(rad(angle)), dy=-W_slope/w*dy_std * np.sin(rad(angle)), shape='full', lw=2, head_width=plot_width/50)\n                ax.text(rect_bottom_centre_x - W_slope/w*dy_std * np.cos(rad(angle)) - 8, rect_bottom_centre_y - W_slope/w*dy_std * np.sin(rad(angle)) - 2, f'{str(round(W_slope,1))} N', ha='right', fontdict={'size':12})\n            if f:\n                ax.arrow(rect_bottom_centre_x, rect_bottom_centre_y, dx=f/w*dy_std * np.cos(rad(angle)) *np.cos(rad(angle)), dy=f/w*dy_std * np.sin(rad(angle)) *np.cos(rad(angle)), shape='full', lw=2, head_width=plot_width/50)\n                ax.text(rect_bottom_centre_x + f/w*dy_std * np.cos(rad(angle)) + 8, rect_bottom_centre_y + f/w*dy_std * np.sin(rad(angle)) + 2, f'{str(round(f,1))} N', ha='left', fontdict={'size':12})        \n\n            ax.set_xlim(0,plot_width)\n            ax.set_ylim(-40,plot_height)\n            ax.set_aspect('equal')\n            ax.axis('off')\n\n            return fig\n\n    with ui.card():\n        @render.text\n        def notes1():\n            return f\"We are interested in whether the block will slide down the slope here.  To do that we will work out the forces along the sloping surface.\"\n\n        @render.text\n        def notes2():\n            return f\"Suppose y is direction perpendicularly upward from the sloping surface.  Since the object sliding down the slope could neither lift off from the sloping service nor sink into the sloping surface, the net force in the y direction has to be zero.  (Recall Newton's law of inertia)\"\n\n        @render.text\n        def notes3():\n            return f\"This is the key point to starting point of the calculations.  Given the weight of the object and the angle of the slope, we can work out the y component of the block\\'s weight.  Consequently, we can calculate friction, using a known or measured coefficient of friction and the normal force, where friction = coefficient of friction x normal force.  Note that the direction of friction must be pointing up-slope, against the downward pull as a result of the block's weight.\"\n\n        @render.text\n        def notes4():\n            return f\"The down-slope force as a result of the block's weight is the x component of the block's weight.\"\n\n        @render.text\n        def notes5():\n            return f\"Weighing and measuring the coefficient of friction on a flat surface and then make prediction is far more convenient than to measure the forces along a slope.  And safer! Imagine dragging a 10 tonne object up and down a hill!\"\n\n        @render.text\n        def notes6():\n            return f\"An interesting point to note is that, just like an object free falling under gravity and ignoring air resistance, the acceleration of the block sliding down the slope is not affect by weight.  As it can be seen in this app that increasing mass in the input merely increases all the forces proportionally.  Try changing \\\"Mass\\\" in the input side-bar!\"\n\n        @render.text\n        def notes7():\n            return f\"Another point is that the condition at which the block will remain stationary depends only on the coefficient of friction and the slope\\'s angle.  It does not depend on the block\\'s weight.  Can you show this mathematically?  Hint: the block remains stationary when down-slope force is less than or equal to friction.\"\n\n", "type": "text"}]